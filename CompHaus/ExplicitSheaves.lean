-- I (Riccardo) will fix this later

-- import Sieves.dagur
-- import Mathlib.CategoryTheory.Sites.Sheaf
-- import Mathlib.Topology.Category.CompHaus.EffectiveEpi

-- universe u v

-- open CategoryTheory CompHaus Opposite CategoryTheory.Limits

-- lemma Extensivity_CompHaus : Extensivity CompHaus := sorry

-- lemma EverythingProj_CompHaus : EverythingIsProjective CompHaus := sorry

-- lemma Is_Mono_Œπ_CompHaus : IsMono_Œπ CompHaus := sorry

-- lemma one (X : CompHaus.{u}) (S : Sieve X) : 
--     S ‚àà (dagurCoverage _ EverythingProj_CompHaus Is_Mono_Œπ_CompHaus
--       Extensivity_CompHaus).toDCoverage.covering X ‚Üí  
--     S ‚àà (coherentCoverage CompHaus).toDCoverage.covering X := by
--   dsimp [dagurCoverage, coherentCoverage, Coverage.toDCoverage] 
--   intro h 
--   obtain ‚ü®T,‚ü®h,hT‚ü©‚ü© := h 
--   use T 
--   refine' ‚ü®_, by assumption‚ü©  
--   simp only [Set.mem_union, Set.mem_setOf_eq] at h 
--   apply Or.elim h 
--   <;> intro h
--   ¬∑ obtain ‚ü®Œ±, x, Xmap, œÄ, h‚ü© := h
--     use Œ±
--     use x
--     use Xmap 
--     use œÄ 
--     refine' ‚ü®h.1,_‚ü©  
--     have he := (effectiveEpiFamily_tfae Xmap œÄ).out 0 1
--     rw [he]
--     letI := h.2
--     exact inferInstance
--   ¬∑ obtain ‚ü®Y, f, h‚ü© := h
--     use Unit
--     use inferInstance 
--     use (fun _ ‚Ü¶ Y) 
--     use (fun _ ‚Ü¶ f)
--     refine' ‚ü®h.1,_‚ü©  
--     have he := (effectiveEpiFamily_tfae (fun (_ : Unit) ‚Ü¶ Y) (fun _ ‚Ü¶ f)).out 0 1
--     rw [he] 
--     rw [CompHaus.epi_iff_surjective _] at h ‚ä¢ 
--     intro x 
--     obtain ‚ü®y,hy‚ü© := h.2 x  
--     use Sigma.Œπ (fun (_ : Unit) ‚Ü¶ Y) Unit.unit y 
--     rw [‚Üê hy]
--     suffices : (f : Y ‚Üí X) = Sigma.Œπ (fun (_ : Unit) ‚Ü¶ Y) Unit.unit ‚â´ Sigma.desc (fun _ ‚Ü¶ f)
--     ¬∑ rw [this]
--       rfl
--     simp only [colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app]        

-- lemma one' : (dagurCoverage Extensivity_CompHaus
--       EverythingProj_CompHaus Is_Mono_Œπ_CompHaus).toGrothendieck = 
--     (coherentTopology CompHaus) := by
--   ext X S  
--   constructor
--   <;> intro h 
--   ¬∑ dsimp [Coverage.toGrothendieck] at *
--     induction h with 
--     | of Y T hT => 
--       ¬∑ apply Coverage.saturate.of 
--         dsimp [coherentCoverage]
--         dsimp [dagurCoverage] at hT 
--         apply Or.elim hT
--         <;> intro h
--         ¬∑ obtain ‚ü®Œ±, x, Xmap, œÄ, h‚ü© := h
--           use Œ±
--           use x
--           use Xmap 
--           use œÄ 
--           refine' ‚ü®h.1,_‚ü©  
--           have he := (effectiveEpiFamily_tfae Xmap œÄ).out 0 1
--           rw [he]
--           letI := h.2
--           exact inferInstance
--         ¬∑ obtain ‚ü®Z, f, h‚ü© := h
--           use Unit
--           use inferInstance 
--           use (fun _ ‚Ü¶ Z) 
--           use (fun _ ‚Ü¶ f)
--           refine' ‚ü®h.1,_‚ü©  
--           have he := (effectiveEpiFamily_tfae (fun (_ : Unit) ‚Ü¶ Z) (fun _ ‚Ü¶ f)).out 0 1
--           rw [he] 
--           rw [CompHaus.epi_iff_surjective _] at h ‚ä¢ 
--           intro x 
--           obtain ‚ü®y,hy‚ü© := h.2 x  
--           use Sigma.Œπ (fun (_ : Unit) ‚Ü¶ Z) Unit.unit y 
--           rw [‚Üê hy]
--           suffices : (f : Z ‚Üí Y) = Sigma.Œπ (fun (_ : Unit) ‚Ü¶ Z) Unit.unit ‚â´ Sigma.desc (fun _ ‚Ü¶ f)
--           ¬∑ rw [this]
--             rfl
--           simp only [colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app]        
--     | top => 
--       ¬∑ apply Coverage.saturate.top 
--     | transitive Y T => 
--       ¬∑ apply Coverage.saturate.transitive Y T
--         ¬∑ assumption
--         ¬∑ assumption  
--   ¬∑ induction h with 
--     | of Y T hT => 
--       ¬∑ dsimp [coherentCoverage] at hT 
--         obtain ‚ü®I, hI, Xmap, f, ‚ü®h, hT‚ü©‚ü© := hT     
--         have he := (effectiveEpiFamily_tfae Xmap f).out 0 1
--         rw [he] at hT 
--         let œÜ := fun (i : I) ‚Ü¶ Sigma.Œπ Xmap i
--         let F := Sigma.desc f
--         let Z := Sieve.generate T
--         let Xs := (‚àê fun (i : I) => Xmap i)
--         let Zf : Sieve Y := Sieve.generate 
--           (Presieve.ofArrows (fun (_ : Unit) ‚Ü¶ Xs) (fun (_ : Unit) ‚Ü¶ F)) 
--         apply Coverage.saturate.transitive Y Zf
--         ¬∑ apply Coverage.saturate.of 
--           dsimp [dagurCoverage]
--           simp only [Set.mem_union, Set.mem_setOf_eq]
--           right
--           use Xs 
--           use F 
--           refine' ‚ü®rfl, inferInstance‚ü©  
--         ¬∑ intro R g hZfg 
--           dsimp at hZfg 
--           rw [Presieve.ofArrows_pUnit] at hZfg
--           obtain ‚ü®W, œà, œÉ, ‚ü®hW, hW'‚ü©‚ü© := hZfg 
--           dsimp [Presieve.singleton] at hW 
--           induction hW
--           rw [‚Üê hW', Sieve.pullback_comp Z]
--           suffices : Sieve.pullback œà ((Sieve.pullback F) Z) ‚àà GrothendieckTopology.sieves
--             (dagurCoverage CompHaus).toGrothendieck R 
--           ¬∑ exact this 
--           apply GrothendieckTopology.pullback_stable' 
--           dsimp [Coverage.toGrothendieck]
--           suffices : Coverage.saturate (dagurCoverage CompHaus) Xs (Z.pullback F)
--           ¬∑ exact this
--           suffices : Sieve.generate (Presieve.ofArrows Xmap œÜ) ‚â§ Z.pullback F
--           ¬∑ apply Coverage.saturate_of_superset _ this
--             apply Coverage.saturate.of 
--             dsimp [dagurCoverage] 
--             left
--             refine' ‚ü®I, hI, Xmap, œÜ, ‚ü®rfl, _‚ü©‚ü© 
--             suffices : Sigma.desc œÜ = ùüô _ 
--             ¬∑ rw [this]
--               exact inferInstance 
--             ext 
--             simp only [colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app, Category.comp_id]
--           intro Q q hq 
--           simp only [Sieve.pullback_apply, Sieve.generate_apply] 
--           simp only [Sieve.generate_apply] at hq    
--           obtain ‚ü®E, e, r, hq‚ü© := hq
--           refine' ‚ü®E, e, r ‚â´ F, ‚ü®_, _‚ü©‚ü©  
--           ¬∑ rw [h]
--             induction hq.1
--             dsimp 
--             simp only [colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app]
--             exact Presieve.ofArrows.mk _
--           ¬∑ rw [‚Üê hq.2]
--             rfl
--     | top => 
--       ¬∑ apply Coverage.saturate.top
--     | transitive Y T => 
--       ¬∑ apply Coverage.saturate.transitive Y T
--         ¬∑ assumption
--         ¬∑ assumption     